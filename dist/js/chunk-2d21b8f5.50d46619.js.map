{"version":3,"sources":["webpack:///./src/components/ModalLogin/index.vue","webpack:///./node_modules/vee-validate/dist/vee-validate.esm.js","webpack:///./src/utils/validators.js","webpack:///./src/components/ModalLogin/index.vue?5686"],"names":["class","close","handleSubmit","id","state","matricula","value","type","errorMensage","placeholder","errorMessage","senha","disabled","isLoading","isCallable","fn","isObject","obj","Array","isArray","isIndex","Number","RULES","resolveRule","isLocator","__locatorRef","isHTMLTag","tag","includes","isFileInputNode","attrs","isYupValidator","validate","hasCheckedAttr","isContainerValue","isEmptyContainer","length","Object","keys","isNotNestedPath","path","test","isNativeMultiSelect","el","tagName","multiple","isNativeMultiSelectNode","hasTruthyBindingValue","undefined","isNaN","shouldHaveValueBinding","cleanupNonNestedPath","replace","getFromPath","object","resolvedValue","split","filter","Boolean","reduce","acc","propKey","setInPath","i","unset","key","splice","unsetPath","pathValues","map","_","idx","slice","join","keysOf","record","injectWithSelf","symbol","def","vm","provides","resolveNextCheckboxValue","currentValue","checkedValue","uncheckedValue","newVal","indexOf","push","normalizeChildren","context","slotProps","slots","default","getBoundValue","hasValueBinding","_value","isEvent","evt","Event","srcElement","normalizeEventValue","input","target","files","from","options","opt","selected","normalizeRules","rules","defineProperty","writable","enumerable","configurable","_$$isNormalized","prev","curr","params","normalizeParams","buildParams","rule","parsedRule","parseRule","name","provided","mapValueToLocator","createLocator","RegExp","locator","crossTable","val","extractLocators","DEFAULT_CONFIG","generateMessage","field","bails","validateOnBlur","validateOnChange","validateOnInput","validateOnModelUpdate","currentConfig","assign","getConfig","async","shouldBail","formData","values","result","_validate","errors","valid","validateFieldWithYup","ctx","form","isValid","message","_generateFieldError","normalizedContext","rulesKeys","_test","error","validator","opts","_a","abortEarly","then","catch","err","Error","fillTargetValues","fieldCtx","normalize","param","es6","equal","a","b","constructor","Map","size","entries","has","get","Set","ArrayBuffer","isView","source","flags","valueOf","prototype","toString","hasOwnProperty","call","FormContextSymbol","Symbol","FormErrorsSymbol","FormInitialValuesSymbol","FieldContextSymbol","ID_COUNTER","useField","fid","MAX_SAFE_INTEGER","initialValue","validateOnMount","valueProp","label","validateOnValueUpdate","normalizeOptions","meta","handleBlur","handleInput","resetValidationState","setValidationState","checked","useValidationState","initValue","normalizedRules","rulesValue","schema","extractRuleFromSchema","validateWithStateMutation","_b","pending","validateSchema","validateValidStateOnly","_c","handleChange","e","newValue","setTouched","isTouched","touched","unwatchValue","watchValue","deep","resetField","handleReset","oldValue","register","unregister","dependencies","rulesVal","deps","dep","depAcc","depName","depValue","oldDeps","shouldValidate","dirty","defaults","setErrors","useErrorsSource","formInitialValues","useFieldValue$1","useMeta","fieldPath","setFieldValue","force","immediate","flush","fieldName","stageInitialValue","messages","errorBag","setFieldErrorBag","inheritAttrs","props","as","String","required","Function","modelValue","emits","validateField","onChangeHandler","emit","onInputHandler","fieldProps","resolveValidationTriggers","baseOnBlur","onBlur","baseOnInput","onInput","baseOnChange","onChange","resolveTag","newModelValue","children","_d","useForm","fields","isSubmitting","fieldsById","existingField","fieldGroup","submitCount","formValues","valuesByFid","setErrorBag","useErrorBag","initialErrors","bag","readonlyInitialValues","initialValues","setInitialValues","useFormInitialValues","useFormMeta","setFieldError","fieldInstance","forEach","fieldItem","setValues","setFieldTouched","f","resetForm","registerField","newPath","unregisterField","isSharingName","find","valueIdx","resultReducer","formCtx","results","r","Promise","all","resolve","preventDefault","stopPropagation","immutableFormValues","validationSchema","shouldMutate","validateYupSchema","submitForm","submit","initialTouched","currentValues","MERGE_STRATEGIES","isDirty","flag","mergeMethod","inner","errorsByPath","aggregatedResult","fieldId","fieldResult","some","providedValues","computedInitials","updateFields","isSafeToUpdate","touchedByUser","onSubmit","handleFormReset","onReset","handleScopedSlotSubmit","onSuccess","this","formAttrs","novalidate","role","validateEmpty","setup","router","modal","useModal","toast","matriculaValue","matriculaErrorMenssage","senhaValue","senhaErrorMenssage","hasErrors","clear","services","auth","login","data","window","localStorage","setItem","token","success","status","__exports__","render"],"mappings":"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","file":"js/chunk-2d21b8f5.50d46619.js","sourcesContent":["<template>\r\n  <div class=\"flex justify-between\">\r\n    <h1 class=\"text-2xl font-black text-gray-800\"> Entrar com Login IFES\r\n    </h1>\r\n    <button\r\n    class=\"text-4xl text-gray-600 focus:outline-none\"\r\n    @click='close'>&times;\r\n    </button>\r\n  </div>\r\n\r\n  <div>\r\n    <div class=\"mt-16\">\r\n      <form @submit.prevent=\"handleSubmit\">\r\n        <label class=\"block\">\r\n          <span class=\"text-lg font-medium text-gray-600\">Matrícula</span>\r\n\r\n          <input\r\n          id=\"matricula-field\"\r\n          v-model=\"state.matricula.value\"\r\n          type=\"text\"\r\n          :class=\"{'border-brand-danger': !!state.matricula.errorMensage}\"\r\n          class=\"clock w-full px-4 py-3 mt-1 text-lg bg-gray-100 border-transparent rounded\"\r\n          placeholder=\"Matrícula\">\r\n\r\n          <span v-if=\"!!state.matricula.errorMessage\"\r\n          class=\"block font-medium text-brand-danger\">\r\n          {{ state.matricula.errorMessage }}\r\n          </span>\r\n        </label>\r\n        <label class=\"block\">\r\n          <span class=\"text-lg font-medium text-gray-600\">Senha</span>\r\n\r\n          <input\r\n          v-model=\"state.senha.value\"\r\n          type=\"password\"\r\n          :class=\"{'border-brand-danger': !!state.senha.errorMensage}\"\r\n          class=\"clock w-full px-4 py-3 mt-1 text-lg bg-gray-100 border-transparent rounded\"\r\n          placeholder=\"Senha\">\r\n\r\n          <span v-if=\"!!state.senha.errorMessage\"\r\n          class=\"block font-medium text-brand-danger\">\r\n          {{ state.senha.errorMessage }}\r\n          </span>\r\n        </label>\r\n        <button :disabled=\"state.isLoading\"\r\n        type=\"submit\"\r\n        :class=\"{'opacity-50': state.isLoading}\"\r\n        class=\"px-8 py-3 mt-10 text-2x1 font-bold text-white rounded bg-brand-main focus:outline-nome\"\r\n        >\r\n          Entrar\r\n        </button>\r\n      </form>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { reactive } from 'vue'\r\nimport { useRouter } from 'vue-router'\r\nimport { useField } from 'vee-validate'\r\nimport { useToast } from 'vue-toastification'\r\nimport useModal from '../../hooks/useModal'\r\nimport { validateEmpty } from '../../utils/validators'\r\nimport services from '../../services'\r\n\r\nexport default {\r\n  setup () {\r\n    const router = useRouter()\r\n    const modal = useModal()\r\n    const toast = useToast()\r\n\r\n    const {\r\n      value: matriculaValue,\r\n      errorMessage: matriculaErrorMenssage\r\n    } = useField('matricula', validateEmpty)\r\n\r\n    const {\r\n      value: senhaValue,\r\n      errorMessage: senhaErrorMenssage\r\n    } = useField('senha', validateEmpty)\r\n\r\n    const state = reactive({\r\n      hasErrors: false,\r\n      isLoading: false,\r\n      matricula: {\r\n        value: matriculaValue,\r\n        errorMessage: matriculaErrorMenssage\r\n      },\r\n      senha: {\r\n        value: senhaValue,\r\n        errorMessage: senhaErrorMenssage\r\n      }\r\n    })\r\n\r\n    async function handleSubmit () {\r\n      try {\r\n        toast.clear()\r\n        state.isLoading = true\r\n        const { data, errors } = await services.auth.login({\r\n          matricula: state.matricula.value,\r\n          senha: state.senha.value\r\n        })\r\n        if (!errors) {\r\n          window.localStorage.setItem('token', data.token)\r\n          router.push({ name: 'Administrador' })\r\n          state.isLoading = false\r\n          modal.close()\r\n          toast.success('Bem vindo!')\r\n          return\r\n        }\r\n        if (errors.status === 404) {\r\n          toast.error('Matrícula não encontrada')\r\n        }\r\n        if (errors.status === 401) {\r\n          toast.error('Matrícula ou senha invalidas')\r\n        }\r\n        if (errors.status === 400) {\r\n          toast.error('Ops, ocorreu um erro ao tentar realizar o login')\r\n        }\r\n        state.isLoading = false\r\n      } catch (error) {\r\n        state.isLoading = false\r\n        state.hasErrors = !!error\r\n        toast.error('Ops, ocorreu um erro ao tentar realizar o login')\r\n      }\r\n    }\r\n\r\n    return {\r\n      state,\r\n      handleSubmit,\r\n      close: modal.close\r\n    }\r\n  }\r\n\r\n}\r\n</script>\r\n","/**\n  * vee-validate v4.2.2\n  * (c) 2021 Abdelrahman Awad\n  * @license MIT\n  */\nimport { inject, getCurrentInstance, warn as warn$1, unref, computed, onMounted, provide, isRef, watch, onBeforeUnmount, reactive, ref, defineComponent, toRef, resolveDynamicComponent, h, nextTick } from 'vue';\n\nfunction isCallable(fn) {\r\n    return typeof fn === 'function';\r\n}\r\nconst isObject = (obj) => obj !== null && !!obj && typeof obj === 'object' && !Array.isArray(obj);\r\nfunction isIndex(value) {\r\n    return Number(value) >= 0;\r\n}\n\nconst RULES = {};\r\n/**\r\n * Adds a custom validator to the list of validation rules.\r\n */\r\nfunction defineRule(id, validator) {\r\n    // makes sure new rules are properly formatted.\r\n    guardExtend(id, validator);\r\n    RULES[id] = validator;\r\n}\r\n/**\r\n * Gets an already defined rule\r\n */\r\nfunction resolveRule(id) {\r\n    return RULES[id];\r\n}\r\n/**\r\n * Guards from extension violations.\r\n */\r\nfunction guardExtend(id, validator) {\r\n    if (isCallable(validator)) {\r\n        return;\r\n    }\r\n    throw new Error(`Extension Error: The validator '${id}' must be a function.`);\r\n}\n\nfunction isLocator(value) {\r\n    return isCallable(value) && !!value.__locatorRef;\r\n}\r\n/**\r\n * Checks if an tag name is a native HTML tag and not a Vue component\r\n */\r\nfunction isHTMLTag(tag) {\r\n    return ['input', 'textarea', 'select'].includes(tag);\r\n}\r\n/**\r\n * Checks if an input is of type file\r\n */\r\nfunction isFileInputNode(tag, attrs) {\r\n    return isHTMLTag(tag) && attrs.type === 'file';\r\n}\r\nfunction isYupValidator(value) {\r\n    return !!value && isCallable(value.validate);\r\n}\r\nfunction hasCheckedAttr(type) {\r\n    return type === 'checkbox' || type === 'radio';\r\n}\r\nfunction isContainerValue(value) {\r\n    return isObject(value) || Array.isArray(value);\r\n}\r\n/**\r\n * True if the value is an empty object or array\r\n */\r\nfunction isEmptyContainer(value) {\r\n    if (Array.isArray(value)) {\r\n        return value.length === 0;\r\n    }\r\n    return isObject(value) && Object.keys(value).length === 0;\r\n}\r\n/**\r\n * Checks if the path opted out of nested fields using `[fieldName]` syntax\r\n */\r\nfunction isNotNestedPath(path) {\r\n    return /^\\[.+\\]$/i.test(path);\r\n}\r\n/**\r\n * Checks if an element is a native HTML5 multi-select input element\r\n */\r\nfunction isNativeMultiSelect(el) {\r\n    return el.tagName === 'SELECT' && el.multiple;\r\n}\r\n/**\r\n * Checks if a tag name with attrs object will render a native multi-select element\r\n */\r\nfunction isNativeMultiSelectNode(tag, attrs) {\r\n    // The falsy value array is the values that Vue won't add the `multiple` prop if it has one of these values\r\n    const hasTruthyBindingValue = ![false, null, undefined, 0].includes(attrs.multiple) && !Number.isNaN(attrs.multiple);\r\n    return tag === 'select' && 'multiple' in attrs && hasTruthyBindingValue;\r\n}\r\n/**\r\n * Checks if a node should have a `:value` binding or not\r\n *\r\n * These nodes should not have a value binding\r\n * For files, because they are not reactive\r\n * For multi-selects because the value binding will reset the value\r\n */\r\nfunction shouldHaveValueBinding(tag, attrs) {\r\n    return isNativeMultiSelectNode(tag, attrs) || isFileInputNode(tag, attrs);\r\n}\n\nfunction cleanupNonNestedPath(path) {\r\n    if (isNotNestedPath(path)) {\r\n        return path.replace(/\\[|\\]/gi, '');\r\n    }\r\n    return path;\r\n}\r\n/**\r\n * Gets a nested property value from an object\r\n */\r\nfunction getFromPath(object, path) {\r\n    if (!object) {\r\n        return undefined;\r\n    }\r\n    if (isNotNestedPath(path)) {\r\n        return object[cleanupNonNestedPath(path)];\r\n    }\r\n    const resolvedValue = path\r\n        .split(/\\.|\\[(\\d+)\\]/)\r\n        .filter(Boolean)\r\n        .reduce((acc, propKey) => {\r\n        if (isContainerValue(acc) && propKey in acc) {\r\n            return acc[propKey];\r\n        }\r\n        return undefined;\r\n    }, object);\r\n    return resolvedValue;\r\n}\r\n/**\r\n * Sets a nested property value in a path, creates the path properties if it doesn't exist\r\n */\r\nfunction setInPath(object, path, value) {\r\n    if (isNotNestedPath(path)) {\r\n        object[cleanupNonNestedPath(path)] = value;\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, set it\r\n        if (i === keys.length - 1) {\r\n            acc[keys[i]] = value;\r\n            return;\r\n        }\r\n        // Key does not exist, create a container for it\r\n        if (!(keys[i] in acc)) {\r\n            // container can be either an object or an array depending on the next key if it exists\r\n            acc[keys[i]] = isIndex(keys[i + 1]) ? [] : {};\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n}\r\nfunction unset(object, key) {\r\n    if (Array.isArray(object) && isIndex(key)) {\r\n        object.splice(Number(key), 1);\r\n        return;\r\n    }\r\n    if (isObject(object)) {\r\n        delete object[key];\r\n    }\r\n}\r\n/**\r\n * Removes a nested property from object\r\n */\r\nfunction unsetPath(object, path) {\r\n    if (isNotNestedPath(path)) {\r\n        delete object[cleanupNonNestedPath(path)];\r\n        return;\r\n    }\r\n    const keys = path.split(/\\.|\\[(\\d+)\\]/).filter(Boolean);\r\n    let acc = object;\r\n    for (let i = 0; i < keys.length; i++) {\r\n        // Last key, unset it\r\n        if (i === keys.length - 1) {\r\n            unset(acc, keys[i]);\r\n            break;\r\n        }\r\n        // Key does not exist, exit\r\n        if (!(keys[i] in acc)) {\r\n            break;\r\n        }\r\n        acc = acc[keys[i]];\r\n    }\r\n    const pathValues = keys.map((_, idx) => {\r\n        return getFromPath(object, keys.slice(0, idx).join('.'));\r\n    });\r\n    for (let i = pathValues.length - 1; i >= 0; i--) {\r\n        if (!isEmptyContainer(pathValues[i])) {\r\n            continue;\r\n        }\r\n        if (i === 0) {\r\n            unset(object, keys[0]);\r\n            continue;\r\n        }\r\n        unset(pathValues[i - 1], keys[i - 1]);\r\n    }\r\n}\r\n/**\r\n * A typed version of Object.keys\r\n */\r\nfunction keysOf(record) {\r\n    return Object.keys(record);\r\n}\r\n// Uses same component provide as its own injections\r\n// Due to changes in https://github.com/vuejs/vue-next/pull/2424\r\nfunction injectWithSelf(symbol, def = undefined) {\r\n    const vm = getCurrentInstance();\r\n    return inject(symbol, (vm === null || vm === void 0 ? void 0 : vm.provides[symbol]) || def);\r\n}\r\nfunction warn(message) {\r\n    warn$1(`[vee-validate]: ${message}`);\r\n}\r\n/**\r\n * Ensures we deal with a singular field value\r\n */\r\nfunction normalizeField(field) {\r\n    if (Array.isArray(field)) {\r\n        return field[0];\r\n    }\r\n    return field;\r\n}\r\nfunction resolveNextCheckboxValue(currentValue, checkedValue, uncheckedValue) {\r\n    if (Array.isArray(currentValue)) {\r\n        const newVal = [...currentValue];\r\n        const idx = newVal.indexOf(checkedValue);\r\n        idx >= 0 ? newVal.splice(idx, 1) : newVal.push(checkedValue);\r\n        return newVal;\r\n    }\r\n    return currentValue === checkedValue ? uncheckedValue : checkedValue;\r\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nconst normalizeChildren = (context, slotProps) => {\r\n    if (!context.slots.default) {\r\n        return context.slots.default;\r\n    }\r\n    return context.slots.default(slotProps);\r\n};\r\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\r\nfunction getBoundValue(el) {\r\n    if (hasValueBinding(el)) {\r\n        return el._value;\r\n    }\r\n    return undefined;\r\n}\r\n/**\r\n * Vue adds a `_value` prop at the moment on the input elements to store the REAL value on them, real values are different than the `value` attribute\r\n * as they do not get casted to strings unlike `el.value` which preserves user-code behavior\r\n */\r\nfunction hasValueBinding(el) {\r\n    return '_value' in el;\r\n}\n\nconst isEvent = (evt) => {\r\n    if (!evt) {\r\n        return false;\r\n    }\r\n    if (typeof Event !== 'undefined' && isCallable(Event) && evt instanceof Event) {\r\n        return true;\r\n    }\r\n    // this is for IE and Cypress #3161\r\n    /* istanbul ignore next */\r\n    if (evt && evt.srcElement) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\nfunction normalizeEventValue(value) {\r\n    if (!isEvent(value)) {\r\n        return value;\r\n    }\r\n    const input = value.target;\r\n    // Vue sets the current bound value on `_value` prop\r\n    // for checkboxes it it should fetch the value binding type as is (boolean instead of string)\r\n    if (hasCheckedAttr(input.type) && hasValueBinding(input)) {\r\n        return getBoundValue(input);\r\n    }\r\n    if (input.type === 'file' && input.files) {\r\n        return Array.from(input.files);\r\n    }\r\n    if (isNativeMultiSelect(input)) {\r\n        return Array.from(input.options)\r\n            .filter(opt => opt.selected && !opt.disabled)\r\n            .map(getBoundValue);\r\n    }\r\n    return input.value;\r\n}\n\n/**\r\n * Normalizes the given rules expression.\r\n */\r\nfunction normalizeRules(rules) {\r\n    const acc = {};\r\n    Object.defineProperty(acc, '_$$isNormalized', {\r\n        value: true,\r\n        writable: false,\r\n        enumerable: false,\r\n        configurable: false,\r\n    });\r\n    if (!rules) {\r\n        return acc;\r\n    }\r\n    // Object is already normalized, skip.\r\n    if (isObject(rules) && rules._$$isNormalized) {\r\n        return rules;\r\n    }\r\n    if (isObject(rules)) {\r\n        return Object.keys(rules).reduce((prev, curr) => {\r\n            const params = normalizeParams(rules[curr]);\r\n            if (rules[curr] !== false) {\r\n                prev[curr] = buildParams(params);\r\n            }\r\n            return prev;\r\n        }, acc);\r\n    }\r\n    /* istanbul ignore if */\r\n    if (typeof rules !== 'string') {\r\n        return acc;\r\n    }\r\n    return rules.split('|').reduce((prev, rule) => {\r\n        const parsedRule = parseRule(rule);\r\n        if (!parsedRule.name) {\r\n            return prev;\r\n        }\r\n        prev[parsedRule.name] = buildParams(parsedRule.params);\r\n        return prev;\r\n    }, acc);\r\n}\r\n/**\r\n * Normalizes a rule param.\r\n */\r\nfunction normalizeParams(params) {\r\n    if (params === true) {\r\n        return [];\r\n    }\r\n    if (Array.isArray(params)) {\r\n        return params;\r\n    }\r\n    if (isObject(params)) {\r\n        return params;\r\n    }\r\n    return [params];\r\n}\r\nfunction buildParams(provided) {\r\n    const mapValueToLocator = (value) => {\r\n        // A target param using interpolation\r\n        if (typeof value === 'string' && value[0] === '@') {\r\n            return createLocator(value.slice(1));\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(provided)) {\r\n        return provided.map(mapValueToLocator);\r\n    }\r\n    // #3073\r\n    if (provided instanceof RegExp) {\r\n        return [provided];\r\n    }\r\n    return Object.keys(provided).reduce((prev, key) => {\r\n        prev[key] = mapValueToLocator(provided[key]);\r\n        return prev;\r\n    }, {});\r\n}\r\n/**\r\n * Parses a rule string expression.\r\n */\r\nconst parseRule = (rule) => {\r\n    let params = [];\r\n    const name = rule.split(':')[0];\r\n    if (rule.includes(':')) {\r\n        params = rule.split(':').slice(1).join(':').split(',');\r\n    }\r\n    return { name, params };\r\n};\r\nfunction createLocator(value) {\r\n    const locator = (crossTable) => {\r\n        const val = getFromPath(crossTable, value) || crossTable[value];\r\n        return val;\r\n    };\r\n    locator.__locatorRef = value;\r\n    return locator;\r\n}\r\nfunction extractLocators(params) {\r\n    if (Array.isArray(params)) {\r\n        return params.filter(isLocator);\r\n    }\r\n    return keysOf(params)\r\n        .filter(key => isLocator(params[key]))\r\n        .map(key => params[key]);\r\n}\n\nconst DEFAULT_CONFIG = {\r\n    generateMessage: ({ field }) => `${field} is not valid.`,\r\n    bails: true,\r\n    validateOnBlur: true,\r\n    validateOnChange: true,\r\n    validateOnInput: false,\r\n    validateOnModelUpdate: true,\r\n};\r\nlet currentConfig = Object.assign({}, DEFAULT_CONFIG);\r\nconst getConfig = () => currentConfig;\r\nconst setConfig = (newConf) => {\r\n    currentConfig = Object.assign(Object.assign({}, currentConfig), newConf);\r\n};\r\nconst configure = setConfig;\n\n/**\r\n * Validates a value against the rules.\r\n */\r\nasync function validate(value, rules, options = {}) {\r\n    const shouldBail = options === null || options === void 0 ? void 0 : options.bails;\r\n    const field = {\r\n        name: (options === null || options === void 0 ? void 0 : options.name) || '{field}',\r\n        rules,\r\n        bails: shouldBail !== null && shouldBail !== void 0 ? shouldBail : true,\r\n        formData: (options === null || options === void 0 ? void 0 : options.values) || {},\r\n    };\r\n    const result = await _validate(field, value);\r\n    const errors = result.errors;\r\n    return {\r\n        errors,\r\n        valid: !errors.length,\r\n    };\r\n}\r\n/**\r\n * Starts the validation process.\r\n */\r\nasync function _validate(field, value) {\r\n    if (isYupValidator(field.rules)) {\r\n        return validateFieldWithYup(value, field.rules, { bails: field.bails });\r\n    }\r\n    // if a generic function, use it as the pipeline.\r\n    if (isCallable(field.rules)) {\r\n        const ctx = {\r\n            field: field.name,\r\n            form: field.formData,\r\n            value: value,\r\n        };\r\n        const result = await field.rules(value, ctx);\r\n        const isValid = typeof result !== 'string' && result;\r\n        const message = typeof result === 'string' ? result : _generateFieldError(ctx);\r\n        return {\r\n            errors: !isValid ? [message] : [],\r\n        };\r\n    }\r\n    const normalizedContext = Object.assign(Object.assign({}, field), { rules: normalizeRules(field.rules) });\r\n    const errors = [];\r\n    const rulesKeys = Object.keys(normalizedContext.rules);\r\n    const length = rulesKeys.length;\r\n    for (let i = 0; i < length; i++) {\r\n        const rule = rulesKeys[i];\r\n        const result = await _test(normalizedContext, value, {\r\n            name: rule,\r\n            params: normalizedContext.rules[rule],\r\n        });\r\n        if (result.error) {\r\n            errors.push(result.error);\r\n            if (field.bails) {\r\n                return {\r\n                    errors,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Handles yup validation\r\n */\r\nasync function validateFieldWithYup(value, validator, opts) {\r\n    var _a;\r\n    const errors = await validator\r\n        .validate(value, {\r\n        abortEarly: (_a = opts.bails) !== null && _a !== void 0 ? _a : true,\r\n    })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name === 'ValidationError') {\r\n            return err.errors;\r\n        }\r\n        // re-throw the error so we don't hide it\r\n        throw err;\r\n    });\r\n    return {\r\n        errors,\r\n    };\r\n}\r\n/**\r\n * Tests a single input value against a rule.\r\n */\r\nasync function _test(field, value, rule) {\r\n    const validator = resolveRule(rule.name);\r\n    if (!validator) {\r\n        throw new Error(`No such validator '${rule.name}' exists.`);\r\n    }\r\n    const params = fillTargetValues(rule.params, field.formData);\r\n    const ctx = {\r\n        field: field.name,\r\n        value,\r\n        form: field.formData,\r\n        rule: Object.assign(Object.assign({}, rule), { params }),\r\n    };\r\n    const result = await validator(value, params, ctx);\r\n    if (typeof result === 'string') {\r\n        return {\r\n            error: result,\r\n        };\r\n    }\r\n    return {\r\n        error: result ? undefined : _generateFieldError(ctx),\r\n    };\r\n}\r\n/**\r\n * Generates error messages.\r\n */\r\nfunction _generateFieldError(fieldCtx) {\r\n    const message = getConfig().generateMessage;\r\n    if (!message) {\r\n        return 'Field is invalid';\r\n    }\r\n    return message(fieldCtx);\r\n}\r\nfunction fillTargetValues(params, crossTable) {\r\n    const normalize = (value) => {\r\n        if (isLocator(value)) {\r\n            return value(crossTable);\r\n        }\r\n        return value;\r\n    };\r\n    if (Array.isArray(params)) {\r\n        return params.map(normalize);\r\n    }\r\n    return Object.keys(params).reduce((acc, param) => {\r\n        acc[param] = normalize(params[param]);\r\n        return acc;\r\n    }, {});\r\n}\n\nvar es6 = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nconst FormContextSymbol = Symbol('vee-validate-form');\r\nconst FormErrorsSymbol = Symbol('vee-validate-form-errors');\r\nconst FormInitialValuesSymbol = Symbol('vee-validate-form-initial-values');\r\nconst FieldContextSymbol = Symbol('vee-validate-field-instance');\n\nlet ID_COUNTER = 0;\r\n/**\r\n * Creates a field composite.\r\n */\r\nfunction useField(name, rules, opts) {\r\n    const fid = ID_COUNTER >= Number.MAX_SAFE_INTEGER ? 0 : ++ID_COUNTER;\r\n    const { initialValue, validateOnMount, bails, type, valueProp, label, validateOnValueUpdate, uncheckedValue, } = normalizeOptions(unref(name), opts);\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    const { meta, errors, errorMessage, handleBlur, handleInput, resetValidationState, setValidationState, value, checked, } = useValidationState({\r\n        name,\r\n        initValue: initialValue,\r\n        form,\r\n        type,\r\n        valueProp,\r\n    });\r\n    const normalizedRules = computed(() => {\r\n        let rulesValue = unref(rules);\r\n        const schema = form === null || form === void 0 ? void 0 : form.schema;\r\n        if (schema && !isYupValidator(schema)) {\r\n            rulesValue = extractRuleFromSchema(schema, unref(name)) || rulesValue;\r\n        }\r\n        if (isYupValidator(rulesValue) || isCallable(rulesValue)) {\r\n            return rulesValue;\r\n        }\r\n        return normalizeRules(rulesValue);\r\n    });\r\n    async function validateWithStateMutation() {\r\n        var _a, _b;\r\n        meta.pending = true;\r\n        let result;\r\n        if (!form || !form.validateSchema) {\r\n            result = await validate(value.value, normalizedRules.value, {\r\n                name: unref(label) || unref(name),\r\n                values: (_a = form === null || form === void 0 ? void 0 : form.values) !== null && _a !== void 0 ? _a : {},\r\n                bails,\r\n            });\r\n        }\r\n        else {\r\n            result = (_b = (await form.validateSchema())[unref(name)]) !== null && _b !== void 0 ? _b : { valid: true, errors: [] };\r\n        }\r\n        meta.pending = false;\r\n        return setValidationState(result);\r\n    }\r\n    async function validateValidStateOnly() {\r\n        var _a, _b, _c;\r\n        let result;\r\n        if (!form || !form.validateSchema) {\r\n            result = await validate(value.value, normalizedRules.value, {\r\n                name: unref(label) || unref(name),\r\n                values: (_a = form === null || form === void 0 ? void 0 : form.values) !== null && _a !== void 0 ? _a : {},\r\n                bails,\r\n            });\r\n        }\r\n        else {\r\n            result = (_c = (_b = (await form.validateSchema(false))) === null || _b === void 0 ? void 0 : _b[unref(name)]) !== null && _c !== void 0 ? _c : { valid: true, errors: [] };\r\n        }\r\n        meta.valid = result.valid;\r\n    }\r\n    // Common input/change event handler\r\n    const handleChange = (e) => {\r\n        var _a, _b;\r\n        if (checked && checked.value === ((_b = (_a = e) === null || _a === void 0 ? void 0 : _a.target) === null || _b === void 0 ? void 0 : _b.checked)) {\r\n            return;\r\n        }\r\n        let newValue = normalizeEventValue(e);\r\n        // Single checkbox field without a form to toggle it's value\r\n        if (checked && type === 'checkbox' && !form) {\r\n            newValue = resolveNextCheckboxValue(value.value, unref(valueProp), unref(uncheckedValue));\r\n        }\r\n        value.value = newValue;\r\n        if (!validateOnValueUpdate) {\r\n            return validateWithStateMutation();\r\n        }\r\n    };\r\n    // Runs the initial validation\r\n    onMounted(() => {\r\n        if (validateOnMount) {\r\n            return validateWithStateMutation();\r\n        }\r\n        // validate self initially if no form was handling this\r\n        // forms should have their own initial silent validation run to make things more efficient\r\n        if (!form || !form.validateSchema) {\r\n            validateValidStateOnly();\r\n        }\r\n    });\r\n    function setTouched(isTouched) {\r\n        meta.touched = isTouched;\r\n    }\r\n    let unwatchValue;\r\n    function watchValue() {\r\n        unwatchValue = watch(value, validateOnValueUpdate ? validateWithStateMutation : validateValidStateOnly, {\r\n            deep: true,\r\n        });\r\n    }\r\n    watchValue();\r\n    function resetField(state) {\r\n        unwatchValue === null || unwatchValue === void 0 ? void 0 : unwatchValue();\r\n        resetValidationState(state);\r\n        watchValue();\r\n    }\r\n    const field = {\r\n        idx: -1,\r\n        fid,\r\n        name,\r\n        value,\r\n        meta,\r\n        errors,\r\n        errorMessage,\r\n        type,\r\n        valueProp,\r\n        uncheckedValue,\r\n        checked,\r\n        resetField,\r\n        handleReset: () => resetField(),\r\n        validate: validateWithStateMutation,\r\n        handleChange,\r\n        handleBlur,\r\n        handleInput,\r\n        setValidationState,\r\n        setTouched,\r\n    };\r\n    provide(FieldContextSymbol, field);\r\n    if (isRef(rules) && typeof unref(rules) !== 'function') {\r\n        watch(rules, (value, oldValue) => {\r\n            if (es6(value, oldValue)) {\r\n                return;\r\n            }\r\n            return validateWithStateMutation();\r\n        }, {\r\n            deep: true,\r\n        });\r\n    }\r\n    // if no associated form return the field API immediately\r\n    if (!form) {\r\n        return field;\r\n    }\r\n    // associate the field with the given form\r\n    form.register(field);\r\n    onBeforeUnmount(() => {\r\n        form.unregister(field);\r\n    });\r\n    // extract cross-field dependencies in a computed prop\r\n    const dependencies = computed(() => {\r\n        const rulesVal = normalizedRules.value;\r\n        // is falsy, a function schema or a yup schema\r\n        if (!rulesVal || isCallable(rulesVal) || isYupValidator(rulesVal)) {\r\n            return {};\r\n        }\r\n        return Object.keys(rulesVal).reduce((acc, rule) => {\r\n            const deps = extractLocators(rulesVal[rule])\r\n                .map((dep) => dep.__locatorRef)\r\n                .reduce((depAcc, depName) => {\r\n                const depValue = getFromPath(form.values, depName) || form.values[depName];\r\n                if (depValue !== undefined) {\r\n                    depAcc[depName] = depValue;\r\n                }\r\n                return depAcc;\r\n            }, {});\r\n            Object.assign(acc, deps);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // Adds a watcher that runs the validation whenever field dependencies change\r\n    watch(dependencies, (deps, oldDeps) => {\r\n        // Skip if no dependencies or if the field wasn't manipulated\r\n        if (!Object.keys(deps).length) {\r\n            return;\r\n        }\r\n        const shouldValidate = !es6(deps, oldDeps);\r\n        if (shouldValidate) {\r\n            meta.dirty ? validateWithStateMutation() : validateValidStateOnly();\r\n        }\r\n    });\r\n    return field;\r\n}\r\n/**\r\n * Normalizes partial field options to include the full options\r\n */\r\nfunction normalizeOptions(name, opts) {\r\n    const defaults = () => ({\r\n        initialValue: undefined,\r\n        validateOnMount: false,\r\n        bails: true,\r\n        rules: '',\r\n        label: name,\r\n        validateOnValueUpdate: true,\r\n    });\r\n    if (!opts) {\r\n        return defaults();\r\n    }\r\n    return Object.assign(Object.assign({}, defaults()), (opts || {}));\r\n}\r\n/**\r\n * Manages the validation state of a field.\r\n */\r\nfunction useValidationState({ name, initValue, form, type, valueProp, }) {\r\n    const { errors, errorMessage, setErrors } = useErrorsSource(name, form);\r\n    const formInitialValues = injectWithSelf(FormInitialValuesSymbol, undefined);\r\n    const initialValue = computed(() => {\r\n        var _a;\r\n        return ((_a = getFromPath(unref(formInitialValues), unref(name))) !== null && _a !== void 0 ? _a : unref(initValue));\r\n    });\r\n    const value = useFieldValue$1(initialValue, name, form);\r\n    const meta = useMeta(initialValue, value, errors);\r\n    const checked = hasCheckedAttr(type)\r\n        ? computed(() => {\r\n            if (Array.isArray(value.value)) {\r\n                return value.value.includes(unref(valueProp));\r\n            }\r\n            return unref(valueProp) === value.value;\r\n        })\r\n        : undefined;\r\n    /**\r\n     * Handles common onBlur meta update\r\n     */\r\n    const handleBlur = () => {\r\n        meta.touched = true;\r\n    };\r\n    /**\r\n     * Handles common on blur events\r\n     */\r\n    const handleInput = (e) => {\r\n        // Checkboxes/Radio will emit a `change` event anyway, custom components will use `update:modelValue`\r\n        // so this is redundant\r\n        if (!hasCheckedAttr(type)) {\r\n            value.value = normalizeEventValue(e);\r\n        }\r\n    };\r\n    // Updates the validation state with the validation result\r\n    function setValidationState(result) {\r\n        setErrors(result.errors);\r\n        return result;\r\n    }\r\n    // Resets the validation state\r\n    function resetValidationState(state) {\r\n        var _a, _b;\r\n        const fieldPath = unref(name);\r\n        const newValue = state && 'value' in state\r\n            ? state.value\r\n            : ((_a = getFromPath(unref(formInitialValues), fieldPath)) !== null && _a !== void 0 ? _a : initValue);\r\n        if (form) {\r\n            form.setFieldValue(fieldPath, newValue, { force: true });\r\n        }\r\n        else {\r\n            value.value = newValue;\r\n        }\r\n        setErrors((state === null || state === void 0 ? void 0 : state.errors) || []);\r\n        meta.touched = (_b = state === null || state === void 0 ? void 0 : state.touched) !== null && _b !== void 0 ? _b : false;\r\n        meta.pending = false;\r\n    }\r\n    return {\r\n        meta,\r\n        errors,\r\n        errorMessage,\r\n        setValidationState,\r\n        resetValidationState,\r\n        handleBlur,\r\n        handleInput,\r\n        value,\r\n        checked,\r\n    };\r\n}\r\n/**\r\n * Exposes meta flags state and some associated actions with them.\r\n */\r\nfunction useMeta(initialValue, currentValue, errors) {\r\n    const meta = reactive({\r\n        touched: false,\r\n        pending: false,\r\n        valid: true,\r\n        initialValue: computed(() => unref(initialValue)),\r\n        dirty: computed(() => {\r\n            return !es6(currentValue.value, unref(initialValue));\r\n        }),\r\n    });\r\n    watch(errors, value => {\r\n        meta.valid = !value.length;\r\n    }, {\r\n        immediate: true,\r\n        flush: 'sync',\r\n    });\r\n    return meta;\r\n}\r\n/**\r\n * Extracts the validation rules from a schema\r\n */\r\nfunction extractRuleFromSchema(schema, fieldName) {\r\n    // no schema at all\r\n    if (!schema) {\r\n        return undefined;\r\n    }\r\n    // there is a key on the schema object for this field\r\n    return schema[fieldName];\r\n}\r\n/**\r\n * Manages the field value\r\n */\r\nfunction useFieldValue$1(initialValue, path, form) {\r\n    // if no form is associated, use a regular ref.\r\n    if (!form) {\r\n        return ref(unref(initialValue));\r\n    }\r\n    // set initial value\r\n    form.stageInitialValue(unref(path), unref(initialValue));\r\n    // otherwise use a computed setter that triggers the `setFieldValue`\r\n    const value = computed({\r\n        get() {\r\n            return getFromPath(form.values, unref(path));\r\n        },\r\n        set(newVal) {\r\n            form.setFieldValue(unref(path), newVal);\r\n        },\r\n    });\r\n    return value;\r\n}\r\nfunction useErrorsSource(path, form) {\r\n    if (!form) {\r\n        const errors = ref([]);\r\n        return {\r\n            errors: computed(() => errors.value),\r\n            errorMessage: computed(() => errors.value[0]),\r\n            setErrors: (messages) => {\r\n                errors.value = messages;\r\n            },\r\n        };\r\n    }\r\n    const errors = computed(() => form.errorBag.value[unref(path)] || []);\r\n    return {\r\n        errors,\r\n        errorMessage: computed(() => errors.value[0]),\r\n        setErrors: (messages) => {\r\n            form.setFieldErrorBag(unref(path), messages);\r\n        },\r\n    };\r\n}\n\nconst Field = defineComponent({\r\n    name: 'Field',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: [String, Object],\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n        rules: {\r\n            type: [Object, String, Function],\r\n            default: undefined,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        validateOnBlur: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnChange: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnInput: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        validateOnModelUpdate: {\r\n            type: Boolean,\r\n            default: undefined,\r\n        },\r\n        bails: {\r\n            type: Boolean,\r\n            default: () => getConfig().bails,\r\n        },\r\n        label: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n        uncheckedValue: {\r\n            type: null,\r\n            default: undefined,\r\n        },\r\n        modelValue: {\r\n            type: null,\r\n        },\r\n    },\r\n    emits: ['update:modelValue'],\r\n    setup(props, ctx) {\r\n        const rules = toRef(props, 'rules');\r\n        const name = toRef(props, 'name');\r\n        const label = toRef(props, 'label');\r\n        const uncheckedValue = toRef(props, 'uncheckedValue');\r\n        const { errors, value, errorMessage, validate: validateField, handleChange, handleBlur, handleInput, setTouched, resetField, handleReset, meta, checked, } = useField(name, rules, {\r\n            validateOnMount: props.validateOnMount,\r\n            bails: props.bails,\r\n            type: ctx.attrs.type,\r\n            // Gets the initial value either from `value` prop/attr or `v-model` binding (modelValue)\r\n            // For checkboxes and radio buttons it will always be the model value not the `value` attribute\r\n            initialValue: hasCheckedAttr(ctx.attrs.type)\r\n                ? props.modelValue\r\n                : 'modelValue' in props\r\n                    ? props.modelValue\r\n                    : ctx.attrs.value,\r\n            // Only for checkboxes and radio buttons\r\n            valueProp: ctx.attrs.value,\r\n            uncheckedValue,\r\n            label,\r\n            validateOnValueUpdate: false,\r\n        });\r\n        // If there is a v-model applied on the component we need to emit the `update:modelValue` whenever the value binding changes\r\n        const onChangeHandler = 'modelValue' in props\r\n            ? function handleChangeWithModel(e) {\r\n                handleChange(e);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleChange;\r\n        const onInputHandler = 'modelValue' in props\r\n            ? function handleChangeWithModel(e) {\r\n                handleInput(e);\r\n                ctx.emit('update:modelValue', value.value);\r\n            }\r\n            : handleInput;\r\n        const fieldProps = computed(() => {\r\n            const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = resolveValidationTriggers(props);\r\n            const baseOnBlur = [handleBlur, ctx.attrs.onBlur, validateOnBlur ? validateField : undefined].filter(Boolean);\r\n            const baseOnInput = [onInputHandler, validateOnInput ? onChangeHandler : undefined, ctx.attrs.onInput].filter(Boolean);\r\n            const baseOnChange = [onInputHandler, validateOnChange ? onChangeHandler : undefined, ctx.attrs.onChange].filter(Boolean);\r\n            const attrs = {\r\n                name: props.name,\r\n                onBlur: baseOnBlur,\r\n                onInput: baseOnInput,\r\n                onChange: baseOnChange,\r\n            };\r\n            if (validateOnModelUpdate) {\r\n                attrs['onUpdate:modelValue'] = [onChangeHandler];\r\n            }\r\n            if (hasCheckedAttr(ctx.attrs.type) && checked) {\r\n                attrs.checked = checked.value;\r\n            }\r\n            else {\r\n                attrs.value = value.value;\r\n            }\r\n            const tag = resolveTag(props, ctx);\r\n            if (shouldHaveValueBinding(tag, ctx.attrs)) {\r\n                delete attrs.value;\r\n            }\r\n            return attrs;\r\n        });\r\n        const slotProps = computed(() => {\r\n            return {\r\n                field: fieldProps.value,\r\n                value: value.value,\r\n                meta,\r\n                errors: errors.value,\r\n                errorMessage: errorMessage.value,\r\n                validate: validateField,\r\n                resetField,\r\n                handleChange: onChangeHandler,\r\n                handleInput: onInputHandler,\r\n                handleReset,\r\n                handleBlur,\r\n                setTouched,\r\n            };\r\n        });\r\n        if ('modelValue' in props) {\r\n            const modelValue = toRef(props, 'modelValue');\r\n            watch(modelValue, newModelValue => {\r\n                if (newModelValue !== value.value) {\r\n                    value.value = newModelValue;\r\n                    validateField();\r\n                }\r\n            });\r\n        }\r\n        return () => {\r\n            const tag = resolveDynamicComponent(resolveTag(props, ctx));\r\n            const children = normalizeChildren(ctx, slotProps.value);\r\n            if (tag) {\r\n                return h(tag, Object.assign(Object.assign({}, ctx.attrs), fieldProps.value), children);\r\n            }\r\n            return children;\r\n        };\r\n    },\r\n});\r\nfunction resolveTag(props, ctx) {\r\n    let tag = props.as || '';\r\n    if (!props.as && !ctx.slots.default) {\r\n        tag = 'input';\r\n    }\r\n    return tag;\r\n}\r\nfunction resolveValidationTriggers(props) {\r\n    var _a, _b, _c, _d;\r\n    const { validateOnInput, validateOnChange, validateOnBlur, validateOnModelUpdate } = getConfig();\r\n    return {\r\n        validateOnInput: (_a = props.validateOnInput) !== null && _a !== void 0 ? _a : validateOnInput,\r\n        validateOnChange: (_b = props.validateOnChange) !== null && _b !== void 0 ? _b : validateOnChange,\r\n        validateOnBlur: (_c = props.validateOnBlur) !== null && _c !== void 0 ? _c : validateOnBlur,\r\n        validateOnModelUpdate: (_d = props.validateOnModelUpdate) !== null && _d !== void 0 ? _d : validateOnModelUpdate,\r\n    };\r\n}\n\nfunction useForm(opts) {\r\n    // A flat array containing field references\r\n    const fields = ref([]);\r\n    // If the form is currently submitting\r\n    const isSubmitting = ref(false);\r\n    // a field map object useful for faster access of fields\r\n    const fieldsById = computed(() => {\r\n        return fields.value.reduce((acc, field) => {\r\n            const fieldPath = unref(field.name);\r\n            // if the field was not added before\r\n            if (!acc[fieldPath]) {\r\n                acc[fieldPath] = field;\r\n                field.idx = -1;\r\n                return acc;\r\n            }\r\n            // if the same name is detected\r\n            const existingField = acc[fieldPath];\r\n            if (!Array.isArray(existingField)) {\r\n                existingField.idx = 0;\r\n                acc[fieldPath] = [existingField];\r\n            }\r\n            const fieldGroup = acc[fieldPath];\r\n            field.idx = fieldGroup.length;\r\n            fieldGroup.push(field);\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // The number of times the user tried to submit the form\r\n    const submitCount = ref(0);\r\n    // a private ref for all form values\r\n    const formValues = reactive({});\r\n    // a lookup to keep track of values by their field ids\r\n    // this is important because later we need it if fields swap names\r\n    const valuesByFid = {};\r\n    // the source of errors for the form fields\r\n    const { errorBag, setErrorBag, setFieldErrorBag } = useErrorBag(opts === null || opts === void 0 ? void 0 : opts.initialErrors);\r\n    // Gets the first error of each field\r\n    const errors = computed(() => {\r\n        return keysOf(errorBag.value).reduce((acc, key) => {\r\n            const bag = errorBag.value[key];\r\n            if (bag && bag.length) {\r\n                acc[key] = bag[0];\r\n            }\r\n            return acc;\r\n        }, {});\r\n    });\r\n    // initial form values\r\n    const { readonlyInitialValues, initialValues, setInitialValues } = useFormInitialValues(fieldsById, formValues, opts === null || opts === void 0 ? void 0 : opts.initialValues);\r\n    // form meta aggregations\r\n    const meta = useFormMeta(fields, formValues, readonlyInitialValues);\r\n    /**\r\n     * Manually sets an error message on a specific field\r\n     */\r\n    function setFieldError(field, message) {\r\n        setFieldErrorBag(field, message);\r\n    }\r\n    /**\r\n     * Sets errors for the fields specified in the object\r\n     */\r\n    function setErrors(fields) {\r\n        setErrorBag(fields);\r\n    }\r\n    /**\r\n     * Sets a single field value\r\n     */\r\n    function setFieldValue(field, value, { force } = { force: false }) {\r\n        var _a;\r\n        const fieldInstance = fieldsById.value[field];\r\n        // Multiple checkboxes, and only one of them got updated\r\n        if (Array.isArray(fieldInstance) && ((_a = fieldInstance[0]) === null || _a === void 0 ? void 0 : _a.type) === 'checkbox' && !Array.isArray(value)) {\r\n            const newVal = resolveNextCheckboxValue(getFromPath(formValues, field) || [], value, undefined);\r\n            setInPath(formValues, field, newVal);\r\n            fieldInstance.forEach(fieldItem => {\r\n                valuesByFid[fieldItem.fid] = newVal;\r\n            });\r\n            return;\r\n        }\r\n        let newValue = value;\r\n        // Single Checkbox: toggles the field value unless the field is being reset then force it\r\n        if (!Array.isArray(fieldInstance) && (fieldInstance === null || fieldInstance === void 0 ? void 0 : fieldInstance.type) === 'checkbox' && !force) {\r\n            newValue = resolveNextCheckboxValue(getFromPath(formValues, field), value, unref(fieldInstance.uncheckedValue));\r\n        }\r\n        setInPath(formValues, field, newValue);\r\n        // multiple radio fields\r\n        if (fieldInstance && Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(fieldItem => {\r\n                valuesByFid[fieldItem.fid] = newValue;\r\n            });\r\n            return;\r\n        }\r\n        if (fieldInstance) {\r\n            valuesByFid[fieldInstance.fid] = newValue;\r\n        }\r\n    }\r\n    /**\r\n     * Sets multiple fields values\r\n     */\r\n    function setValues(fields) {\r\n        keysOf(fields).forEach(field => {\r\n            setFieldValue(field, fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Sets the touched meta state on a field\r\n     */\r\n    function setFieldTouched(field, isTouched) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            return;\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            fieldInstance.forEach(f => f.setTouched(isTouched));\r\n            return;\r\n        }\r\n        fieldInstance.setTouched(isTouched);\r\n    }\r\n    /**\r\n     * Sets the touched meta state on multiple fields\r\n     */\r\n    function setTouched(fields) {\r\n        keysOf(fields).forEach(field => {\r\n            setFieldTouched(field, !!fields[field]);\r\n        });\r\n    }\r\n    /**\r\n     * Resets all fields\r\n     */\r\n    const resetForm = (state) => {\r\n        // set initial values if provided\r\n        if (state === null || state === void 0 ? void 0 : state.values) {\r\n            setInitialValues(state.values);\r\n        }\r\n        // Reset all fields state\r\n        fields.value.forEach(f => f.resetField());\r\n        if (state === null || state === void 0 ? void 0 : state.touched) {\r\n            setTouched(state.touched);\r\n        }\r\n        if (state === null || state === void 0 ? void 0 : state.errors) {\r\n            setErrors(state.errors);\r\n        }\r\n        submitCount.value = (state === null || state === void 0 ? void 0 : state.submitCount) || 0;\r\n    };\r\n    function registerField(field) {\r\n        fields.value.push(field);\r\n        if (isRef(field.name)) {\r\n            valuesByFid[field.fid] = field.value.value;\r\n            // ensures when a field's name was already taken that it preserves its same value\r\n            // necessary for fields generated by loops\r\n            watch(field.name, newPath => {\r\n                setFieldValue(newPath, valuesByFid[field.fid]);\r\n            }, {\r\n                flush: 'post',\r\n            });\r\n        }\r\n    }\r\n    function unregisterField(field) {\r\n        var _a, _b;\r\n        const idx = fields.value.indexOf(field);\r\n        if (idx === -1) {\r\n            return;\r\n        }\r\n        fields.value.splice(idx, 1);\r\n        const fid = field.fid;\r\n        // cleans up the field value from fid lookup\r\n        nextTick(() => {\r\n            delete valuesByFid[fid];\r\n        });\r\n        const fieldName = unref(field.name);\r\n        // in this case, this is a single field not a group (checkbox or radio)\r\n        // so remove the field value key immediately\r\n        if (field.idx === -1) {\r\n            // avoid un-setting the value if the field was switched with another that shares the same name\r\n            // #3166\r\n            const isSharingName = fields.value.find(f => unref(f.name) === fieldName);\r\n            if (isSharingName) {\r\n                return;\r\n            }\r\n            unsetPath(formValues, fieldName);\r\n            unsetPath(initialValues.value, fieldName);\r\n            return;\r\n        }\r\n        // otherwise find the actual value in the current array of values and remove it\r\n        const valueIdx = (_b = (_a = getFromPath(formValues, fieldName)) === null || _a === void 0 ? void 0 : _a.indexOf) === null || _b === void 0 ? void 0 : _b.call(_a, unref(field.valueProp));\r\n        if (valueIdx === undefined) {\r\n            unsetPath(formValues, fieldName);\r\n            return;\r\n        }\r\n        if (valueIdx === -1) {\r\n            return;\r\n        }\r\n        if (Array.isArray(formValues[fieldName])) {\r\n            unsetPath(formValues, `${fieldName}.${valueIdx}`);\r\n            return;\r\n        }\r\n        unsetPath(formValues, fieldName);\r\n        unsetPath(initialValues.value, fieldName);\r\n    }\r\n    async function validate() {\r\n        function resultReducer(acc, result) {\r\n            if (!result.errors.length) {\r\n                return acc;\r\n            }\r\n            acc.valid = false;\r\n            acc.errors[result.key] = result.errors[0];\r\n            return acc;\r\n        }\r\n        if (formCtx.validateSchema) {\r\n            return formCtx.validateSchema(true).then(results => {\r\n                return keysOf(results)\r\n                    .map(r => ({ key: r, errors: results[r].errors }))\r\n                    .reduce(resultReducer, { errors: {}, valid: true });\r\n            });\r\n        }\r\n        const results = await Promise.all(fields.value.map(f => {\r\n            return f.validate().then((result) => {\r\n                return {\r\n                    key: unref(f.name),\r\n                    errors: result.errors,\r\n                };\r\n            });\r\n        }));\r\n        return results.reduce(resultReducer, { errors: {}, valid: true });\r\n    }\r\n    async function validateField(field) {\r\n        const fieldInstance = fieldsById.value[field];\r\n        if (!fieldInstance) {\r\n            warn$1(`field with name ${field} was not found`);\r\n            return Promise.resolve({ errors: [], valid: true });\r\n        }\r\n        if (Array.isArray(fieldInstance)) {\r\n            return fieldInstance.map(f => f.validate())[0];\r\n        }\r\n        return fieldInstance.validate();\r\n    }\r\n    const handleSubmit = (fn) => {\r\n        return function submissionHandler(e) {\r\n            if (e instanceof Event) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n            isSubmitting.value = true;\r\n            submitCount.value++;\r\n            return validate()\r\n                .then(result => {\r\n                if (result.valid && typeof fn === 'function') {\r\n                    return fn(immutableFormValues.value, {\r\n                        evt: e,\r\n                        setErrors,\r\n                        setFieldError,\r\n                        setTouched,\r\n                        setFieldTouched,\r\n                        setValues,\r\n                        setFieldValue,\r\n                        resetForm,\r\n                    });\r\n                }\r\n            })\r\n                .then(() => {\r\n                isSubmitting.value = false;\r\n            }, err => {\r\n                isSubmitting.value = false;\r\n                // re-throw the err so it doesn't go silent\r\n                throw err;\r\n            });\r\n        };\r\n    };\r\n    /**\r\n     * Sneaky function to set initial field values\r\n     */\r\n    function stageInitialValue(path, value) {\r\n        setInPath(formValues, path, value);\r\n        setInPath(initialValues.value, path, value);\r\n    }\r\n    const formCtx = {\r\n        register: registerField,\r\n        unregister: unregisterField,\r\n        fieldsById,\r\n        values: formValues,\r\n        setFieldErrorBag,\r\n        errorBag,\r\n        schema: opts === null || opts === void 0 ? void 0 : opts.validationSchema,\r\n        submitCount,\r\n        validateSchema: isYupValidator(opts === null || opts === void 0 ? void 0 : opts.validationSchema)\r\n            ? (shouldMutate = false) => {\r\n                return validateYupSchema(formCtx, shouldMutate);\r\n            }\r\n            : undefined,\r\n        validate,\r\n        validateField,\r\n        setFieldValue,\r\n        setValues,\r\n        setErrors,\r\n        setFieldError,\r\n        setFieldTouched,\r\n        setTouched,\r\n        resetForm,\r\n        meta,\r\n        isSubmitting,\r\n        handleSubmit,\r\n        stageInitialValue,\r\n    };\r\n    const immutableFormValues = computed(() => {\r\n        return fields.value.reduce((formData, field) => {\r\n            setInPath(formData, unref(field.name), unref(field.value));\r\n            return formData;\r\n        }, {});\r\n    });\r\n    const submitForm = handleSubmit((_, { evt }) => {\r\n        var _a, _b;\r\n        if (evt) {\r\n            (_b = (_a = evt === null || evt === void 0 ? void 0 : evt.target) === null || _a === void 0 ? void 0 : _a.submit) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n    });\r\n    // Trigger initial validation\r\n    onMounted(() => {\r\n        if (opts === null || opts === void 0 ? void 0 : opts.initialErrors) {\r\n            setErrors(opts.initialErrors);\r\n        }\r\n        if (opts === null || opts === void 0 ? void 0 : opts.initialTouched) {\r\n            setTouched(opts.initialTouched);\r\n        }\r\n        // if validate on mount was enabled\r\n        if (opts === null || opts === void 0 ? void 0 : opts.validateOnMount) {\r\n            validate();\r\n            return;\r\n        }\r\n        // otherwise run initial silent validation through schema if available\r\n        // the useField should skip their own silent validation if a yup schema is present\r\n        if (formCtx.validateSchema) {\r\n            formCtx.validateSchema(false);\r\n        }\r\n    });\r\n    // Provide injections\r\n    provide(FormContextSymbol, formCtx);\r\n    provide(FormErrorsSymbol, errors);\r\n    return {\r\n        errors,\r\n        meta,\r\n        values: formValues,\r\n        isSubmitting,\r\n        submitCount,\r\n        validate,\r\n        validateField,\r\n        handleReset: () => resetForm(),\r\n        resetForm,\r\n        handleSubmit,\r\n        submitForm,\r\n        setFieldError,\r\n        setErrors,\r\n        setFieldValue,\r\n        setValues,\r\n        setFieldTouched,\r\n        setTouched,\r\n    };\r\n}\r\n/**\r\n * Manages form meta aggregation\r\n */\r\nfunction useFormMeta(fields, currentValues, initialValues) {\r\n    const MERGE_STRATEGIES = {\r\n        touched: 'some',\r\n        pending: 'some',\r\n        valid: 'every',\r\n    };\r\n    const isDirty = computed(() => {\r\n        return !es6(currentValues, unref(initialValues));\r\n    });\r\n    return computed(() => {\r\n        const flags = keysOf(MERGE_STRATEGIES).reduce((acc, flag) => {\r\n            const mergeMethod = MERGE_STRATEGIES[flag];\r\n            acc[flag] = fields.value[mergeMethod](field => field.meta[flag]);\r\n            return acc;\r\n        }, {});\r\n        return Object.assign(Object.assign({ initialValues: unref(initialValues) }, flags), { dirty: isDirty.value });\r\n    });\r\n}\r\nasync function validateYupSchema(form, shouldMutate = false) {\r\n    const errors = await form.schema\r\n        .validate(form.values, { abortEarly: false })\r\n        .then(() => [])\r\n        .catch((err) => {\r\n        // Yup errors have a name prop one them.\r\n        // https://github.com/jquense/yup#validationerrorerrors-string--arraystring-value-any-path-string\r\n        if (err.name !== 'ValidationError') {\r\n            throw err;\r\n        }\r\n        // list of aggregated errors\r\n        return err.inner || [];\r\n    });\r\n    const fieldsById = form.fieldsById.value || {};\r\n    const errorsByPath = errors.reduce((acc, err) => {\r\n        acc[err.path] = err;\r\n        return acc;\r\n    }, {});\r\n    // Aggregates the validation result\r\n    const aggregatedResult = keysOf(fieldsById).reduce((result, fieldId) => {\r\n        const field = fieldsById[fieldId];\r\n        const messages = (errorsByPath[fieldId] || { errors: [] }).errors;\r\n        const fieldResult = {\r\n            errors: messages,\r\n            valid: !messages.length,\r\n        };\r\n        result[fieldId] = fieldResult;\r\n        const isTouched = Array.isArray(field) ? field.some(f => f.meta.touched) : field.meta.touched;\r\n        if (!shouldMutate && !isTouched) {\r\n            // Update the valid flag regardless to keep it accurate\r\n            if (Array.isArray(field)) {\r\n                field.forEach(f => (f.meta.valid = fieldResult.valid));\r\n            }\r\n            else {\r\n                field.meta.valid = fieldResult.valid;\r\n            }\r\n            return result;\r\n        }\r\n        if (Array.isArray(field)) {\r\n            field[0].setValidationState(fieldResult);\r\n            return result;\r\n        }\r\n        field.setValidationState(fieldResult);\r\n        return result;\r\n    }, {});\r\n    return aggregatedResult;\r\n}\r\n/**\r\n * Manages the initial values prop\r\n */\r\nfunction useFormInitialValues(fields, formValues, providedValues) {\r\n    const initialValues = ref(unref(providedValues) || {});\r\n    // acts as a read only proxy of the initial values object\r\n    const computedInitials = computed(() => {\r\n        return initialValues.value;\r\n    });\r\n    function setInitialValues(values, updateFields = false) {\r\n        initialValues.value = Object.assign(Object.assign({}, initialValues.value), values);\r\n        if (!updateFields) {\r\n            return;\r\n        }\r\n        // update the pristine (non-touched fields)\r\n        // we exclude dirty and untouched fields because it's unlikely you want to change the form values using initial values\r\n        // we mostly watch them for API population or newly inserted fields\r\n        const isSafeToUpdate = (f) => f.meta.touched;\r\n        keysOf(fields.value).forEach(fieldPath => {\r\n            const field = fields.value[fieldPath];\r\n            const touchedByUser = Array.isArray(field) ? field.some(isSafeToUpdate) : isSafeToUpdate(field);\r\n            if (touchedByUser) {\r\n                return;\r\n            }\r\n            const newValue = getFromPath(initialValues.value, fieldPath);\r\n            setInPath(formValues, fieldPath, newValue);\r\n        });\r\n    }\r\n    if (isRef(providedValues)) {\r\n        watch(providedValues, value => {\r\n            setInitialValues(value, true);\r\n        }, {\r\n            deep: true,\r\n        });\r\n    }\r\n    provide(FormInitialValuesSymbol, computedInitials);\r\n    return {\r\n        readonlyInitialValues: computedInitials,\r\n        initialValues,\r\n        setInitialValues,\r\n    };\r\n}\r\nfunction useErrorBag(initialErrors) {\r\n    const errorBag = ref({});\r\n    /**\r\n     * Manually sets an error message on a specific field\r\n     */\r\n    function setFieldErrorBag(field, message) {\r\n        errorBag.value[field] = Array.isArray(message) ? message : message ? [message] : [];\r\n    }\r\n    /**\r\n     * Sets errors for the fields specified in the object\r\n     */\r\n    function setErrorBag(fields) {\r\n        keysOf(fields).forEach(field => {\r\n            setFieldErrorBag(field, fields[field]);\r\n        });\r\n    }\r\n    if (initialErrors) {\r\n        setErrorBag(initialErrors);\r\n    }\r\n    return {\r\n        errorBag,\r\n        setErrorBag,\r\n        setFieldErrorBag,\r\n    };\r\n}\n\nconst Form = defineComponent({\r\n    name: 'Form',\r\n    inheritAttrs: false,\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: 'form',\r\n        },\r\n        validationSchema: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialValues: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialErrors: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        initialTouched: {\r\n            type: Object,\r\n            default: undefined,\r\n        },\r\n        validateOnMount: {\r\n            type: Boolean,\r\n            default: false,\r\n        },\r\n        onSubmit: {\r\n            type: Function,\r\n            default: undefined,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const initialValues = toRef(props, 'initialValues');\r\n        const { errors, values, meta, isSubmitting, submitCount, validate, validateField, handleReset, resetForm, handleSubmit, submitForm, setErrors, setFieldError, setFieldValue, setValues, setFieldTouched, setTouched, } = useForm({\r\n            validationSchema: props.validationSchema,\r\n            initialValues,\r\n            initialErrors: props.initialErrors,\r\n            initialTouched: props.initialTouched,\r\n            validateOnMount: props.validateOnMount,\r\n        });\r\n        const onSubmit = props.onSubmit ? handleSubmit(props.onSubmit) : submitForm;\r\n        function handleFormReset(e) {\r\n            if (isEvent(e)) {\r\n                // Prevent default form reset behavior\r\n                e.preventDefault();\r\n            }\r\n            handleReset();\r\n            if (typeof ctx.attrs.onReset === 'function') {\r\n                ctx.attrs.onReset();\r\n            }\r\n        }\r\n        function handleScopedSlotSubmit(evt, onSubmit) {\r\n            const onSuccess = typeof evt === 'function' && !onSubmit ? evt : onSubmit;\r\n            return handleSubmit(onSuccess)(evt);\r\n        }\r\n        const slotProps = computed(() => {\r\n            return {\r\n                meta: meta.value,\r\n                errors: errors.value,\r\n                values: values,\r\n                isSubmitting: isSubmitting.value,\r\n                submitCount: submitCount.value,\r\n                validate,\r\n                validateField,\r\n                handleSubmit: handleScopedSlotSubmit,\r\n                handleReset,\r\n                submitForm,\r\n                setErrors,\r\n                setFieldError,\r\n                setFieldValue,\r\n                setValues,\r\n                setFieldTouched,\r\n                setTouched,\r\n                resetForm,\r\n            };\r\n        });\r\n        return function renderForm() {\r\n            // FIXME: Hacky but cute way to expose some stuff to the rendered instance\r\n            // getCurrentInstance doesn't work with render fns, it returns the wrong instance\r\n            // we want to expose setFieldError and setErrors\r\n            if (!('setErrors' in this)) {\r\n                this.setFieldError = setFieldError;\r\n                this.setErrors = setErrors;\r\n                this.setFieldValue = setFieldValue;\r\n                this.setValues = setValues;\r\n                this.setFieldTouched = setFieldTouched;\r\n                this.setTouched = setTouched;\r\n                this.resetForm = resetForm;\r\n                this.validate = validate;\r\n                this.validateField = validateField;\r\n            }\r\n            const children = normalizeChildren(ctx, slotProps.value);\r\n            if (!props.as) {\r\n                return children;\r\n            }\r\n            // Attributes to add on a native `form` tag\r\n            const formAttrs = props.as === 'form'\r\n                ? {\r\n                    // Disables native validation as vee-validate will handle it.\r\n                    novalidate: true,\r\n                }\r\n                : {};\r\n            return h(\r\n            // avoid resolving the form component as itself\r\n            props.as === 'form' ? props.as : resolveDynamicComponent(props.as), Object.assign(Object.assign(Object.assign({}, formAttrs), ctx.attrs), { onSubmit, onReset: handleFormReset }), children);\r\n        };\r\n    },\r\n});\n\nconst ErrorMessage = defineComponent({\r\n    props: {\r\n        as: {\r\n            type: String,\r\n            default: undefined,\r\n        },\r\n        name: {\r\n            type: String,\r\n            required: true,\r\n        },\r\n    },\r\n    setup(props, ctx) {\r\n        const errors = inject(FormErrorsSymbol, undefined);\r\n        const message = computed(() => {\r\n            return errors === null || errors === void 0 ? void 0 : errors.value[props.name];\r\n        });\r\n        return () => {\r\n            // Renders nothing if there are no messages\r\n            if (!message.value) {\r\n                return undefined;\r\n            }\r\n            const children = normalizeChildren(ctx, {\r\n                message: message.value,\r\n            });\r\n            const tag = (props.as ? resolveDynamicComponent(props.as) : props.as);\r\n            const attrs = Object.assign({ role: 'alert' }, ctx.attrs);\r\n            // If no tag was specified and there are children\r\n            // render the slot as is without wrapping it\r\n            if (!tag && (children === null || children === void 0 ? void 0 : children.length)) {\r\n                return children;\r\n            }\r\n            // If no children in slot\r\n            // render whatever specified and fallback to a <span> with the message in it's contents\r\n            if (!(children === null || children === void 0 ? void 0 : children.length)) {\r\n                return h(tag || 'span', attrs, message.value);\r\n            }\r\n            return h(tag, attrs, children);\r\n        };\r\n    },\r\n});\n\nfunction useResetForm() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return function resetForm(state) {\r\n        if (!form) {\r\n            return;\r\n        }\r\n        return form.resetForm(state);\r\n    };\r\n}\n\n/**\r\n * If a field is dirty or not\r\n */\r\nfunction useIsFieldDirty(path) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    let field = path ? undefined : inject(FieldContextSymbol);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.dirty;\r\n    });\r\n}\n\n/**\r\n * If a field is touched or not\r\n */\r\nfunction useIsFieldTouched(path) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    let field = path ? undefined : inject(FieldContextSymbol);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.touched;\r\n    });\r\n}\n\n/**\r\n * If a field is validated and is valid\r\n */\r\nfunction useIsFieldValid(path) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    let field = path ? undefined : inject(FieldContextSymbol);\r\n    return computed(() => {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return false;\r\n        }\r\n        return field.meta.valid;\r\n    });\r\n}\n\n/**\r\n * If the form is submitting or not\r\n */\r\nfunction useIsSubmitting() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.isSubmitting.value) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * Validates a single field\r\n */\r\nfunction useValidateField(path) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    let field = path ? undefined : inject(FieldContextSymbol);\r\n    return function validateField() {\r\n        if (path) {\r\n            field = normalizeField(form === null || form === void 0 ? void 0 : form.fieldsById.value[unref(path)]);\r\n        }\r\n        if (!field) {\r\n            warn(`field with name ${unref(path)} was not found`);\r\n            return Promise.resolve({\r\n                errors: [],\r\n                valid: true,\r\n            });\r\n        }\r\n        return field.validate();\r\n    };\r\n}\n\n/**\r\n * If the form is dirty or not\r\n */\r\nfunction useIsFormDirty() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.dirty) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * If the form is touched or not\r\n */\r\nfunction useIsFormTouched() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.touched) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * If the form has been validated and is valid\r\n */\r\nfunction useIsFormValid() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.meta.value.valid) !== null && _a !== void 0 ? _a : false;\r\n    });\r\n}\n\n/**\r\n * Validate multiple fields\r\n */\r\nfunction useValidateForm() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return function validateField() {\r\n        if (!form) {\r\n            return Promise.resolve({ errors: {}, valid: true });\r\n        }\r\n        return form.validate();\r\n    };\r\n}\n\n/**\r\n * The number of form's submission count\r\n */\r\nfunction useSubmitCount() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        var _a;\r\n        return (_a = form === null || form === void 0 ? void 0 : form.submitCount.value) !== null && _a !== void 0 ? _a : 0;\r\n    });\r\n}\n\n/**\r\n * Gives access to a field's current value\r\n */\r\nfunction useFieldValue(path) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    // We don't want to use self injected context as it doesn't make sense\r\n    const field = path ? undefined : inject(FieldContextSymbol);\r\n    return computed(() => {\r\n        var _a;\r\n        if (path) {\r\n            return getFromPath(form === null || form === void 0 ? void 0 : form.values, unref(path));\r\n        }\r\n        return (_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.value;\r\n    });\r\n}\n\n/**\r\n * Gives access to a form's values\r\n */\r\nfunction useFormValues() {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return computed(() => {\r\n        return (form === null || form === void 0 ? void 0 : form.values) || {};\r\n    });\r\n}\n\n/**\r\n * Gives access to all form errors\r\n */\r\nfunction useFormErrors() {\r\n    const errors = injectWithSelf(FormErrorsSymbol);\r\n    if (!errors) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    return errors || computed(() => ({}));\r\n}\n\n/**\r\n * Gives access to a single field error\r\n */\r\nfunction useFieldError(path) {\r\n    const errors = injectWithSelf(FormErrorsSymbol);\r\n    // We don't want to use self injected context as it doesn't make sense\r\n    const field = path ? undefined : inject(FieldContextSymbol);\r\n    return computed(() => {\r\n        var _a;\r\n        if (path) {\r\n            return (_a = errors === null || errors === void 0 ? void 0 : errors.value) === null || _a === void 0 ? void 0 : _a[unref(path)];\r\n        }\r\n        return field === null || field === void 0 ? void 0 : field.errorMessage.value;\r\n    });\r\n}\n\nfunction useSubmitForm(cb) {\r\n    const form = injectWithSelf(FormContextSymbol);\r\n    if (!form) {\r\n        warn('No vee-validate <Form /> or `useForm` was detected in the component tree');\r\n    }\r\n    const onSubmit = form ? form.handleSubmit(cb) : undefined;\r\n    return function submitForm(e) {\r\n        if (!onSubmit) {\r\n            return;\r\n        }\r\n        return onSubmit(e);\r\n    };\r\n}\n\nexport { ErrorMessage, Field, Form, configure, defineRule, useField, useFieldError, useFieldValue, useForm, useFormErrors, useFormValues, useIsFieldDirty, useIsFieldTouched, useIsFieldValid, useIsFormDirty, useIsFormTouched, useIsFormValid, useIsSubmitting, useResetForm, useSubmitCount, useSubmitForm, useValidateField, useValidateForm, validate };\n","export function validateEmpty (value) {\r\n  if (!value) {\r\n    return '*Campo obrigatório'\r\n  }\r\n  return true\r\n}\r\n","import { render } from \"./index.vue?vue&type=template&id=a8c78246\"\nimport script from \"./index.vue?vue&type=script&lang=js\"\nexport * from \"./index.vue?vue&type=script&lang=js\"\n\nimport exportComponent from \"D:\\\\BSI VINICIUS\\\\IC matemática\\\\MVC\\\\lemv\\\\node_modules\\\\@vue\\\\cli-service\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__"],"sourceRoot":""}